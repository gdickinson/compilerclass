/*
  parser.y
  A parser specification for Bison
  Guy Dickinson <guy.dickinson@nyu.edu>

  Compiler Design, Fall 2012
  New York University
*/

%{

// PROLOGUE
#include <stdio.h>
#include <stdlib.h>

// References for stuff generated by flex
extern int yylex();
extern int yyparse();
extern FILE *yyin;

void yyerror(const char *s);

%}

// VALUE TYPE UNION
// We only ever deal with strings and ints, so this is pretty easy
%union {
  int ival;
  char* sval;
}

// Keywords
%token AND
%token ASSIGN
%token BEGN //BEGIN is a reserved word in flex-land
%token FORWARD
%token DIV
%token DO
%token ELSE
%token END
%token FOR
%token FUNCTION
%token IF
%token ARRAY
%token MOD
%token NOT
%token OF
%token OR
%token PROCEDURE
%token PROGRAM
%token RECORD
%token THEN
%token TO
%token TYPE
%token VAR
%token WHILE

// Special Characters
%token SEMIC
%token DOUBLEDOT
%token DOT
%token COMMA
%token COLON
%token LPAR
%token RPAR
%token LBKT
%token RBKT

// Operators -- defined individually because their semantics are context-sensitive
%token PLUS
%token MINUS
%token DIVIDE
%token MULTIPLY
%token LESSTHAN
%token GREATERTHAN
%token LEQ //    (<=)
%token GEQ //   (>=)
%token DIAMOND // (<>)
%token EQUALS

// Value Types
%token <ival> INTEGER
%token <sval> STRING
%token <sval> ID

%%

// GRAMMAR RULES
program:
                PROGRAM ID SEMIC
                type_definitions
                variable_declarations
                subprogram_declarations
                compound_statement
                DOT
                { printf("Matched program rule (Start Symbol)\n"); }
;

type_definitions:
               TYPE type_definitions_list
        |      // Epsilon
        ;

type_definitions_list:
                type_definitions_list type_definition
        |       type_definition
                { printf("type_definitions_list fired\n"); }
        ;

type_definition:
                ID EQUALS type SEMIC
                { printf("type_definition fired\n"); }
        ;

type:
                ID
        |       ARRAY OF type
        |       ARRAY OF LBKT constant DOUBLEDOT constant RBKT
        |       RECORD field_list END
                { printf("type fired\n"); }
        ;

field_list:
                identifier_list COLON type
        |       field_list SEMIC field_list
                { printf("field_list fired\n"); }
        ;


variable_declarations:
                VAR variable_declarations_list
        |       // Epsilon
                { printf("variable_declarations fired\n"); }
        ;

variable_declarations_list:
                variable_declarations_list variable_declaration
        |       variable_declaration
                { printf("variable_declarations_list fired\n"); }
        ;

variable_declaration:
                identifier_list COLON type SEMIC
                { printf("variable declaration fired\n"); }
        ;

subprogram_declarations:
                subprogram_declaration_list
        |       // Epsilon
                { printf("subprogram_declarations fired\n"); }
        ;


subprogram_declaration_list:
                subprogram_declaration_list SEMIC subprogram_declaration
        |       subprogram_declaration
                { printf("subprogram_declaration_list fired\n"); }
        ;

subprogram_declaration:
                procedure_declaration
        |       function_declaration
                { printf("subprogram_declaration fired\n"); }
        ;

block:
                variable_declarations compound_statement
                compound_statement
                { printf("block fired\n"); }
        ;

procedure_declaration:
                PROCEDURE ID LPAR formal_parameters RPAR SEMIC block
        |       PROCEDURE ID LPAR formal_parameters RPAR SEMIC FORWARD
                { printf("procedure_declaration fired\n"); }
        ;

/* block_or_forward: */
/*                 block */
/*         |       FORWARD */
/*         ; */

function_declaration:
                FUNCTION ID LPAR formal_parameters RPAR COLON result_type SEMIC block
        |       FUNCTION ID LPAR formal_parameters RPAR COLON result_type SEMIC FORWARD
                { printf("function_declaration fired\n"); }
        ;

formal_parameters:
                formal_parameter_list
        |       // Epsilon
                { printf("formal_parameters fired\n"); }
        ;

formal_parameter_list:
                formal_parameter SEMIC formal_parameter_list
        |       formal_parameter
                { printf("formal_parameter_list fired\n"); }
        ;

formal_parameter:
                identifier_list COLON type
                { printf("formal_parameter fired\n"); }
        ;

compound_statement:
                BEGN statement_sequence END
                { printf("compound_statement fired\n"); }
        ;

statement_sequence:
                statement_sequence SEMIC statement
        |       statement
                { printf("statement_sequence fired\n"); }
        ;

statement:
                simple_statement
        |       structured_statement
                { printf("statement fired\n"); }
        ;

simple_statement:
                assignment_statement
        |       procedure_statement
        |       // Epsilon
                { printf("simple_statement fired\n"); }
        ;

assignment_statement:
                variable ASSIGN expression
                { printf("assignment_statement fired\n"); }
        ;

component_selection:
                DOT ID component_selection
        |       LBKT expression RBKT component_selection
        |       // Epsilon
//                              DOT ID component_selection
//                      |       expression component_selection
//                      |       component_selection
//                      |       // Epsilon

                { printf("component_selection fired\n"); }
        ;

structured_statement:
                compound_statement
        |       IF expression THEN statement
        |       IF expression THEN statement ELSE statement
        |       WHILE expression DO statement
                { printf("structured_statement fired\n"); }
        ;


procedure_statement:
                ID LPAR actual_parameter_list RPAR
                { printf("procedure_statement\n"); }
        ;

actual_parameter_list:
                expression_list
                { printf("actual_parameter_list\n"); }
        ;

expression_list:
                expression_list COMMA expression
        |       expression
                { printf("expression_list\n"); }
        ;

result_type:
                ID
                {printf ("result_type\n"); }
        ;


constant:
                INTEGER
        |       sign INTEGER
                { printf("constant\n"); }
        ;

expression:
                simple_expression
        |       simple_expression relational_op simple_expression
                { printf("expression\n"); }
        ;

relational_op:
                LESSTHAN
        |       GREATERTHAN
        |       LEQ
        |       GEQ
        |       DIAMOND
        |       EQUALS
                { printf("relational_op\n"); }
        ;

simple_expression:
                term
        |       sign term
        |       simple_expression add_op term
                {printf("simple_expression\n"); }
        ;

add_op:
                PLUS
        |       MINUS
        |       OR
                { printf("add_op\n"); }
        ;

term:
                factor
        |       factor mul_op term
                { printf("term\n"); }
        ;

mul_op:
                MULTIPLY
        |       DIV
        |       MOD
        |       AND
                { printf("mul_op\n"); }
        ;

factor:
                INTEGER
        |       STRING
        |       variable
        |       function_reference
        |       NOT factor
        |       LPAR expression RPAR
                { printf ("factor\n"); }
        ;

function_reference:
                ID LPAR actual_parameter_list RPAR
                { printf("function_reference\n"); }
        ;

variable:
                ID component_selection
                {printf("variable\n"); }
        ;

identifier_list:
                identifier_list COMMA ID
        |       ID
                { printf("identifier_list\n"); }
        ;

sign:
                PLUS
        |       MINUS
                { printf("sign\n"); }
        ;


%%

int main(int argc, char** argv) {
    yydebug = 1;
    FILE *input;
    if (argc > 1) {
        input = fopen(argv[1], "r");
        if (!input) {
            printf("Could not open input file: %s\n", argv[1]);
            exit(-1);
        }
    } else {
        input = stdin;
    }
    yyin = input;
    do {
        yyparse();
    } while (!feof(yyin));

}

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}
