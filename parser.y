/*
  parser.y
  A parser specification for Bison
  Guy Dickinson <guy.dickinson@nyu.edu>

  Compiler Design, Fall 2012
  New York University
*/

%{
// PROLOGUE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "symtab.h"

#define MAX_SAVED_SYMBOLS 20

// References for stuff generated by flex
extern int yylex();
extern int yyparse();
extern int yylineno;
extern FILE *yyin;

void yyerror(const char *s);

typedef struct idlist {
    symbol *syms[MAX_SAVED_SYMBOLS];
    int cnt;
} idlist;

idlist* saved_symbols;

void insert_saved_symbol(symbol* sym, idlist* list);
void reset_saved_symbols(idlist* list);
void process_saved_symbols(idlist* list, char* type);

%}
%verbose
%error-verbose

// VALUE TYPE UNION
%union {
  int ival;
  char* sval;
  symbol* sym;
}

// Keywords
%token AND
%token ASSIGN
%token BEGN //BEGIN is a reserved word in flex-land
%token FORWARD
%token DIV
%token DO
%token ELSE
%token END
%token FOR
%token FUNCTION
%token IF
%token ARRAY
%token MOD
%token NOT
%token OF
%token OR
%token PROCEDURE
%token PROGRAM
%token RECORD
%token THEN
%token TO
%token TYPE
%token VAR
%token WHILE

// Special Characters
%token SEMIC
%token DOUBLEDOT
%token DOT
%token COMMA
%token COLON
%token LPAR
%token RPAR
%token LBKT
%token RBKT

// Operators -- defined individually because their semantics are context-sensitive
%token PLUS
%token MINUS
%token DIVIDE
%token MULTIPLY
%token LESSTHAN
%token GREATERTHAN
%token LEQ //    (<=)
%token GEQ //   (>=)
%token DIAMOND // (<>)
%token EQUALS

// Value Types
%token <ival> INTEGER
%token <sval> STRING
%token <sym> ID

// Some nonterminals have types so we can manipulate the symbol table
%type <sval> type

%%

// GRAMMAR RULES
program:
                PROGRAM ID SEMIC
                type_definitions
                variable_declarations
                subprogram_declarations
                compound_statement
                DOT
                {   $2->type = "PROGRAM";
                    printf("Matched program rule (Start Symbol)\n"); }
;

type_definitions:
                TYPE type_definitions_list
        |      //Epsilon
                { printf("type_definitions\n"); }
        ;

type_definitions_list:
                type_definitions_list type_definition
        |       type_definition
                { printf("type_definitions_list \n"); }
        ;

type_definition:
                ID EQUALS type SEMIC
                { $1->type = $3;
                  printf("type_definition \n"); }
        ;

type:
                ID {$$ = $1->name; printf("type\n");}
        |       ARRAY OF type {$$ = "ARRAY"; printf("type\n");}
        |       ARRAY LBKT constant DOUBLEDOT constant RBKT OF type {$$ = "ARRAY"; printf("type\n");}
        |       RECORD field_list END {$$ = "RECORD"; printf("type\n");}
        ;

field_list:
                identifier_list COLON type
        |       field_list SEMIC field_list
                {   reset_saved_symbols(saved_symbols);
                    printf("field_list \n"); }
        ;


variable_declarations:
                VAR variable_declarations_list
        |       // Epsilon
                { printf("variable_declarations \n"); }
        ;

variable_declarations_list:
                variable_declarations_list variable_declaration
        |       variable_declaration
                { printf("variable_declarations_list \n"); }
        ;

variable_declaration:
                identifier_list COLON type SEMIC
                { process_saved_symbols(saved_symbols, $3);
                  reset_saved_symbols(saved_symbols);
                  printf("variable declaration \n"); }
        ;

subprogram_declarations:
                subprogram_declaration_list
        |       // Epsilon
                { printf("subprogram_declarations \n"); }
        ;


subprogram_declaration_list:
                subprogram_declaration_list subprogram_declaration
        |       subprogram_declaration
                { printf("subprogram_declaration_list \n"); }
        ;

subprogram_declaration:
                procedure_declaration SEMIC
        |       function_declaration SEMIC
                { printf("subprogram_declaration \n"); }
        ;

block:
                variable_declarations compound_statement
        |       compound_statement
                { printf("block \n"); }
        ;

procedure_declaration:
                PROCEDURE ID LPAR formal_parameters RPAR SEMIC block_or_forward
                {
                $2->type = malloc(100);
                sprintf($2->type, "PROCEDURE(%d args)", saved_symbols->cnt);
                reset_saved_symbols(saved_symbols);
                printf("procedure_declaration \n"); }
        ;

block_or_forward:
                block
         |      FORWARD
                {printf("block_or_forward\n");}
         ;

function_declaration:
                FUNCTION ID LPAR formal_parameters RPAR COLON result_type SEMIC block_or_forward
                {
                $2->type = malloc(100);
                sprintf($2->type, "FUNCTION (%d args)", saved_symbols->cnt);
                reset_saved_symbols(saved_symbols);
                printf("function_declaration \n"); }
        ;

formal_parameters:
                formal_parameter_list
        |       // Epsilon
                { printf("formal_parameters \n"); }
        ;

formal_parameter_list:
                formal_parameter SEMIC formal_parameter_list
        |       formal_parameter
                { printf("formal_parameter_list \n"); }
        ;

formal_parameter:
                identifier_list COLON type
                { process_saved_symbols(saved_symbols, $3);
                printf("formal_parameter \n"); }
        ;

compound_statement:
                BEGN statement_sequence END
                { printf("compound_statement \n"); }
        ;

statement_sequence:
                statement_sequence SEMIC statement
        |       statement
                { printf("statement_sequence \n"); }
        ;

statement:
                simple_statement
        |       structured_statement
                { printf("statement\n"); }
        ;

simple_statement:
                assignment_statement
        |       procedure_statement
        |       // Epsilon
                { printf("simple_statement\n"); }
        ;

assignment_statement:
                variable ASSIGN expression
                { printf("assignment_statement\n"); }
        ;

component_selection:
                DOT ID
        |       LBKT expression RBKT component_selection
        |       // Epsilon
                { printf("component_selection\n"); }
        ;

structured_statement:
                compound_statement
        |       IF expression THEN statement
        |       IF expression THEN statement ELSE statement
        |       WHILE expression DO statement
        |       FOR ID ASSIGN expression TO expression DO statement
                { printf("structured_statement\n"); }
        ;

procedure_statement:
                ID LPAR actual_parameter_list RPAR
                { printf("procedure_statement\n"); }
        ;

actual_parameter_list:
                expression_list
        |       //Epsilon
                { printf("actual_parameter_list\n"); }
        ;

expression_list:
                expression_list COMMA expression
        |       expression
                { printf("expression_list\n"); }
        ;

result_type:
                ID
                {printf ("result_type\n"); }
        ;


constant:
                INTEGER
        |       sign INTEGER
                { printf("constant\n"); }
        ;

expression:
                simple_expression
        |       simple_expression relational_op simple_expression
                { printf("expression\n"); }
        ;

relational_op:
                LESSTHAN
        |       GREATERTHAN
        |       LEQ
        |       GEQ
        |       DIAMOND
        |       EQUALS
                { printf("relational_op\n"); }
        ;

simple_expression:
                term
        |       sign term
        |       simple_expression add_op term
                {printf("simple_expression\n"); }
        ;

add_op:
                PLUS
        |       MINUS
        |       OR
                { printf("add_op\n"); }
        ;

term:
                factor
        |       factor mul_op term
                { printf("term\n"); }
        ;

mul_op:
                MULTIPLY
        |       DIV
        |       MOD
        |       AND
                { printf("mul_op\n"); }
        ;

factor:
                INTEGER
        |       STRING
        |       variable
        |       function_reference
        |       NOT factor
        |       LPAR expression RPAR
                { printf ("factor\n"); }
        ;

function_reference:
                ID LPAR actual_parameter_list RPAR
                { printf("function_reference\n"); }
        ;

variable:
                ID component_selection
                {printf("variable\n"); }
        ;

identifier_list:
                identifier_list COMMA ID {insert_saved_symbol($3, saved_symbols);}
        |       ID {insert_saved_symbol($1, saved_symbols);}
                { printf("identifier_list\n"); }
        ;

sign:
                PLUS
        |       MINUS
                { printf("sign\n"); }
        ;


%%

void insert_saved_symbol(symbol* sym, idlist* list) {
    list->syms[list->cnt] = sym;
    list->cnt++;
}

void reset_saved_symbols(idlist* list) {
    list->cnt = 0;
}

void process_saved_symbols(idlist* list, char* type) {
    int i;
    for (i = 0; i < list->cnt; i++) {
    list->syms[i]->type = type;
    }
}

int main(int argc, char** argv) {

    // Initialize globals
    symtab = malloc(sizeof(symbol) * MAX_SYMBOLS);
    saved_symbols = malloc(sizeof(idlist));

    FILE *input;
    if (argc > 1) {
        input = fopen(argv[1], "r");
        if (!input) {
            printf("Could not open input file: %s\n", argv[1]);
            exit(-1);
        }
    } else {
        input = stdin;
    }
    yyin = input;

    do {
        yyparse();
    } while (!feof(yyin));

    // Print out the symbol table
    print_table(symtab);

    // Free globals
    free(symtab);
    free(saved_symbols);
}

void yyerror(const char *s) {
    printf("Error: %s (line %d)\n", s, yylineno);
}
